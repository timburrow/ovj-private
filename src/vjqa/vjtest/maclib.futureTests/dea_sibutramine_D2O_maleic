" This macro is for the compound sibutramine HCl monohydrate "

"change the following $purity with correct value"
$purity=98.64

" using the solvent: D2O "
" and file: /home/data/SFL6/sibutramine_hcl_d2o_01/sibutramine_hcl_d2o_Quant_001.fid "

$name=`sibutramine HCl monohydrate`
$mw=334.32   "molecular weight"

$solubility=0.0    "mg/mL"

" Internal standard information "
$is_name=`maleic`
$is_mw=116.07
$is_num_H=2
$is_pos1=6.50p
$is_pos2=6.00p
" Library Search spectrum name (if any) in /data/LibrarySearch_d2o "
$libraryname=``

$multipleform=`n`

"argument 1 is either library or searchwidth"
"if argument is searchwidth then second argument is the width in Hz"
"example:  dea_drug_D2O_maleic(`library`)"
"example:  dea_drug_D2O_maleic(`searchwidth`,100)"
$numintegrals=8

"Ideal integrals and number of hydrogens for the integral"
"  $fromfirstpeak and $fromlastpeak are number Hz required to set integral "
"  to left and right of first and last peaks.  This is used for multiplets "
"  with small undetected peaks on the ends of the integral. "

" $intleft and $intright are in ppm "
$intleft[1]=7.512  $intright[1]=7.462  $numH[1]=4.0000 $useint[1]=`y`
$intleft[2]=3.782  $intright[2]=3.701  $numH[2]=1.0000 $useint[2]=`y`
$intleft[3]=2.900  $intright[3]=2.850  $numH[3]=3.0000 $useint[3]=`y`
$intleft[4]=2.640  $intright[4]=2.343  $numH[4]=4 $useint[4]=`y`
$intleft[5]=2.290  $intright[5]=2.240  $numH[5]=3 $useint[5]=`y`
$intleft[6]=2.021  $intright[6]=1.595  $numH[6]=4 $useint[6]=`y`
$intleft[7]=1.535  $intright[7]=1.414  $numH[7]=1 $useint[7]=`y`
$intleft[8]=1.081  $intright[8]=0.976  $numH[8]=6.0000 $useint[8]=`y`

$macroname=`dea_sibutramine_D2O_maleic`

$macroname=`dea_sibutramine_D2O_maleic`

"Equation coefficients for 3rd order equation for well resolved peaks"
"using 3 Hz normalization of maleic acid: "

"PPM       Ax2       Bx       C     dres_range  eqn_error"
$peakppm[1]=7.487  $A[1]=-0.077  $B[1]=46.163  $C[1]=9.490
  $dreslo[1]=2.84 $dreshi[1]=3.94 $dres3hz[1]=3.14  $diffmax[1]=0.00
    $pf[1]=153.819
$peakppm[2]=3.756  $A[2]=0  $B[2]=0  $C[2]=0
    $dreslo[2]=15.46 $dreshi[2]=16.16 $dres3hz[2]=15.81  $diffmax[2]=0
    $pf[2]=2961.456
$peakppm[3]=3.741  $A[3]=-20.556  $B[3]=323.118  $C[3]=685.610
  $dreslo[3]=5.61 $dreshi[3]=6.65 $dres3hz[3]=5.98  $diffmax[3]=0.02
    $pf[3]=1882.930
$peakppm[4]=3.726  $A[4]=0  $B[4]=0  $C[4]=0
    $dreslo[4]=15.37 $dreshi[4]=16.07 $dres3hz[4]=15.72  $diffmax[4]=0
    $pf[4]=2871.212
$peakppm[5]=2.875  $A[5]=0.290  $B[5]=57.991  $C[5]=28.341
  $dreslo[5]=3.20 $dreshi[5]=4.28 $dres3hz[5]=3.49  $diffmax[5]=0.00
    $pf[5]=234.264
$peakppm[6]=2.576  $A[6]=0  $B[6]=0  $C[6]=0
    $dreslo[6]=18.25 $dreshi[6]=18.95 $dres3hz[6]=18.60  $diffmax[6]=0
    $pf[6]=3282.539
$peakppm[7]=2.554  $A[7]=0  $B[7]=0  $C[7]=0
    $dreslo[7]=25.96 $dreshi[7]=26.66 $dres3hz[7]=26.31  $diffmax[7]=0
    $pf[7]=4451.071
$peakppm[8]=2.507  $A[8]=-44.281  $B[8]=1031.020  $C[8]=84.617
  $dreslo[8]=3.89 $dreshi[8]=4.99 $dres3hz[8]=4.18  $diffmax[8]=0.00
    $pf[8]=3622.615
$peakppm[9]=2.485  $A[9]=-89.566  $B[9]=1288.826  $C[9]=-2980.638
  $dreslo[9]=5.55 $dreshi[9]=6.42 $dres3hz[9]=5.73  $diffmax[9]=0.01
    $pf[9]=1463.557
$peakppm[10]=2.458  $A[10]=-46.040  $B[10]=717.605  $C[10]=-1277.602
  $dreslo[10]=5.15 $dreshi[10]=6.12 $dres3hz[10]=5.38  $diffmax[10]=0.00
    $pf[10]=1250.307
$peakppm[11]=2.435  $A[11]=-41.561  $B[11]=641.051  $C[11]=-566.639
  $dreslo[11]=5.61 $dreshi[11]=6.98 $dres3hz[11]=5.99  $diffmax[11]=0.01
    $pf[11]=1782.639
$peakppm[12]=2.419  $A[12]=0  $B[12]=0  $C[12]=0
    $dreslo[12]=40.52 $dreshi[12]=41.22 $dres3hz[12]=40.87  $diffmax[12]=0
    $pf[12]=3648.881
$peakppm[13]=2.408  $A[13]=0  $B[13]=0  $C[13]=0
    $dreslo[13]=20.16 $dreshi[13]=20.86 $dres3hz[13]=20.51  $diffmax[13]=0
    $pf[13]=3190.106
$peakppm[14]=2.264  $A[14]=0.250  $B[14]=58.276  $C[14]=26.939
  $dreslo[14]=3.19 $dreshi[14]=4.26 $dres3hz[14]=3.48  $diffmax[14]=0.00
    $pf[14]=232.622
$peakppm[15]=1.955  $A[15]=0  $B[15]=0  $C[15]=0
    $dreslo[15]=22.85 $dreshi[15]=23.55 $dres3hz[15]=23.20  $diffmax[15]=0
    $pf[15]=4608.985
$peakppm[16]=1.945  $A[16]=0  $B[16]=0  $C[16]=0
    $dreslo[16]=22.15 $dreshi[16]=22.85 $dres3hz[16]=22.50  $diffmax[16]=0
    $pf[16]=4147.098
$peakppm[17]=1.934  $A[17]=0  $B[17]=0  $C[17]=0
    $dreslo[17]=21.71 $dreshi[17]=22.41 $dres3hz[17]=22.06  $diffmax[17]=0
    $pf[17]=3905.543
$peakppm[18]=1.924  $A[18]=0  $B[18]=0  $C[18]=0
    $dreslo[18]=26.92 $dreshi[18]=27.62 $dres3hz[18]=27.27  $diffmax[18]=0
    $pf[18]=5523.812
$peakppm[19]=1.859  $A[19]=-39.813  $B[19]=882.812  $C[19]=903.899
  $dreslo[19]=4.64 $dreshi[19]=6.06 $dres3hz[19]=5.09  $diffmax[19]=0.03
    $pf[19]=4366.409
$peakppm[20]=1.836  $A[20]=-88.772  $B[20]=1280.928  $C[20]=-2093.297
  $dreslo[20]=5.70 $dreshi[20]=6.84 $dres3hz[20]=5.98  $diffmax[20]=0.00
    $pf[20]=2392.282
$peakppm[21]=1.814  $A[21]=0  $B[21]=0  $C[21]=0
    $dreslo[21]=16.91 $dreshi[21]=17.61 $dres3hz[21]=17.26  $diffmax[21]=0
    $pf[21]=2130.887
$peakppm[22]=1.797  $A[22]=0  $B[22]=0  $C[22]=0
    $dreslo[22]=26.50 $dreshi[22]=27.20 $dres3hz[22]=26.85  $diffmax[22]=0
    $pf[22]=2965.668
$peakppm[23]=1.786  $A[23]=0  $B[23]=0  $C[23]=0
    $dreslo[23]=26.71 $dreshi[23]=27.41 $dres3hz[23]=27.06  $diffmax[23]=0
    $pf[23]=3112.527
$peakppm[24]=1.765  $A[24]=0  $B[24]=0  $C[24]=0
    $dreslo[24]=41.96 $dreshi[24]=42.66 $dres3hz[24]=42.31  $diffmax[24]=0
    $pf[24]=5660.353
$peakppm[25]=1.692  $A[25]=0  $B[25]=0  $C[25]=0
    $dreslo[25]=32.37 $dreshi[25]=33.07 $dres3hz[25]=32.72  $diffmax[25]=0
    $pf[25]=5979.129
$peakppm[26]=1.680  $A[26]=0  $B[26]=0  $C[26]=0
    $dreslo[26]=32.16 $dreshi[26]=32.86 $dres3hz[26]=32.51  $diffmax[26]=0
    $pf[26]=5569.868
$peakppm[27]=1.672  $A[27]=0  $B[27]=0  $C[27]=0
    $dreslo[27]=32.89 $dreshi[27]=33.59 $dres3hz[27]=33.24  $diffmax[27]=0
    $pf[27]=7452.274
$peakppm[28]=1.655  $A[28]=0  $B[28]=0  $C[28]=0
    $dreslo[28]=12.65 $dreshi[28]=13.35 $dres3hz[28]=13.00  $diffmax[28]=0
    $pf[28]=3321.466
$peakppm[29]=1.642  $A[29]=0  $B[29]=0  $C[29]=0
    $dreslo[29]=13.64 $dreshi[29]=14.34 $dres3hz[29]=13.99  $diffmax[29]=0
    $pf[29]=3922.060
$peakppm[30]=1.634  $A[30]=0  $B[30]=0  $C[30]=0
    $dreslo[30]=18.42 $dreshi[30]=19.12 $dres3hz[30]=18.77  $diffmax[30]=0
    $pf[30]=4599.989
$peakppm[31]=1.621  $A[31]=0  $B[31]=0  $C[31]=0
    $dreslo[31]=19.50 $dreshi[31]=20.20 $dres3hz[31]=19.85  $diffmax[31]=0
    $pf[31]=5454.203
$peakppm[32]=1.510  $A[32]=0  $B[32]=0  $C[32]=0
    $dreslo[32]=18.69 $dreshi[32]=19.39 $dres3hz[32]=19.04  $diffmax[32]=0
    $pf[32]=4731.016
$peakppm[33]=1.493  $A[33]=-73.123  $B[33]=1049.065  $C[33]=-492.703
  $dreslo[33]=4.24 $dreshi[33]=5.42 $dres3hz[33]=4.55  $diffmax[33]=0.00
    $pf[33]=2767.481
$peakppm[34]=1.475  $A[34]=-123.372  $B[34]=1670.798  $C[34]=-1695.264
  $dreslo[34]=5.20 $dreshi[34]=6.42 $dres3hz[34]=5.49  $diffmax[34]=0.01
    $pf[34]=3758.480
$peakppm[35]=1.455  $A[35]=-116.192  $B[35]=1628.704  $C[35]=-853.244
  $dreslo[35]=4.21 $dreshi[35]=5.38 $dres3hz[35]=4.52  $diffmax[35]=0.01
    $pf[35]=4133.843
$peakppm[36]=1.439  $A[36]=0  $B[36]=0  $C[36]=0
    $dreslo[36]=32.52 $dreshi[36]=33.22 $dres3hz[36]=32.87  $diffmax[36]=0
    $pf[36]=7798.207
$peakppm[37]=1.056  $A[37]=-11.352  $B[37]=178.205  $C[37]=-40.948
  $dreslo[37]=3.28 $dreshi[37]=4.45 $dres3hz[37]=3.60  $diffmax[37]=0.01
    $pf[37]=453.884
$peakppm[38]=1.040  $A[38]=-12.628  $B[38]=187.781  $C[38]=-44.191
  $dreslo[38]=3.29 $dreshi[38]=4.49 $dres3hz[38]=3.63  $diffmax[38]=0.02
    $pf[38]=471.072
$peakppm[39]=1.017  $A[39]=-11.548  $B[39]=177.640  $C[39]=-39.227
  $dreslo[39]=3.28 $dreshi[39]=4.47 $dres3hz[39]=3.62  $diffmax[39]=0.01
    $pf[39]=452.194
$peakppm[40]=1.001  $A[40]=-13.000  $B[40]=191.091  $C[40]=-48.805
  $dreslo[40]=3.28 $dreshi[40]=4.48 $dres3hz[40]=3.62  $diffmax[40]=0.02
    $pf[40]=472.295

$peakppm[1]=7.487    $peakht[1]=150.0  $peakintnum[1]=1  $dres[1]=3.14 $usepeak[1]=`y`
$peakppm[2]=3.756    $peakht[2]=7.8  $peakintnum[2]=2  $dres[2]=15.81 $usepeak[2]=`y`
$peakppm[3]=3.741    $peakht[3]=12.3  $peakintnum[3]=2  $dres[3]=5.98 $usepeak[3]=`y`
$peakppm[4]=3.726    $peakht[4]=8.0  $peakintnum[4]=2  $dres[4]=15.72 $usepeak[4]=`y`
$peakppm[5]=2.875    $peakht[5]=98.5  $peakintnum[5]=3  $dres[5]=3.49 $usepeak[5]=`y`
$peakppm[6]=2.576    $peakht[6]=7.0  $peakintnum[6]=4  $dres[6]=18.60 $usepeak[6]=`y`
$peakppm[7]=2.554    $peakht[7]=5.2  $peakintnum[7]=4  $dres[7]=26.31 $usepeak[7]=`y`
$peakppm[8]=2.507    $peakht[8]=6.4  $peakintnum[8]=4  $dres[8]=4.18 $usepeak[8]=`y`
$peakppm[9]=2.485    $peakht[9]=15.8  $peakintnum[9]=4  $dres[9]=5.73 $usepeak[9]=`y`
$peakppm[10]=2.458    $peakht[10]=18.5  $peakintnum[10]=4  $dres[10]=5.38 $usepeak[10]=`y`
$peakppm[11]=2.435    $peakht[11]=12.9  $peakintnum[11]=4  $dres[11]=5.99 $usepeak[11]=`y`
$peakppm[12]=2.419    $peakht[12]=6.3  $peakintnum[12]=4  $dres[12]=40.87 $usepeak[12]=`y`
$peakppm[13]=2.408    $peakht[13]=7.2  $peakintnum[13]=4  $dres[13]=20.51 $usepeak[13]=`y`
$peakppm[14]=2.264    $peakht[14]=99.2  $peakintnum[14]=5  $dres[14]=3.48 $usepeak[14]=`y`
$peakppm[15]=1.955    $peakht[15]=5.0  $peakintnum[15]=6  $dres[15]=23.20 $usepeak[15]=`y`
$peakppm[16]=1.945    $peakht[16]=5.6  $peakintnum[16]=6  $dres[16]=22.50 $usepeak[16]=`y`
$peakppm[17]=1.934    $peakht[17]=5.9  $peakintnum[17]=6  $dres[17]=22.06 $usepeak[17]=`y`
$peakppm[18]=1.924    $peakht[18]=4.2  $peakintnum[18]=6  $dres[18]=27.27 $usepeak[18]=`y`
$peakppm[19]=1.859    $peakht[19]=5.3  $peakintnum[19]=6  $dres[19]=5.09 $usepeak[19]=`y`
$peakppm[20]=1.836    $peakht[20]=9.6  $peakintnum[20]=6  $dres[20]=5.98 $usepeak[20]=`y`
$peakppm[21]=1.814    $peakht[21]=10.8  $peakintnum[21]=6  $dres[21]=17.26 $usepeak[21]=`y`
$peakppm[22]=1.797    $peakht[22]=7.8  $peakintnum[22]=6  $dres[22]=26.85 $usepeak[22]=`y`
$peakppm[23]=1.786    $peakht[23]=7.4  $peakintnum[23]=6  $dres[23]=27.06 $usepeak[23]=`y`
$peakppm[24]=1.765    $peakht[24]=4.1  $peakintnum[24]=6  $dres[24]=42.31 $usepeak[24]=`y`
$peakppm[25]=1.692    $peakht[25]=3.9  $peakintnum[25]=6  $dres[25]=32.72 $usepeak[25]=`y`
$peakppm[26]=1.680    $peakht[26]=4.1  $peakintnum[26]=6  $dres[26]=32.51 $usepeak[26]=`y`
$peakppm[27]=1.672    $peakht[27]=3.1  $peakintnum[27]=6  $dres[27]=33.24 $usepeak[27]=`y`
$peakppm[28]=1.655    $peakht[28]=6.9  $peakintnum[28]=6  $dres[28]=13.00 $usepeak[28]=`y`
$peakppm[29]=1.642    $peakht[29]=5.9  $peakintnum[29]=6  $dres[29]=13.99 $usepeak[29]=`y`
$peakppm[30]=1.634    $peakht[30]=5.0  $peakintnum[30]=6  $dres[30]=18.77 $usepeak[30]=`y`
$peakppm[31]=1.621    $peakht[31]=4.2  $peakintnum[31]=6  $dres[31]=19.85 $usepeak[31]=`y`
$peakppm[32]=1.510    $peakht[32]=4.9  $peakintnum[32]=7  $dres[32]=19.04 $usepeak[32]=`y`
$peakppm[33]=1.493    $peakht[33]=8.3  $peakintnum[33]=7  $dres[33]=4.55 $usepeak[33]=`y`
$peakppm[34]=1.475    $peakht[34]=6.1  $peakintnum[34]=7  $dres[34]=5.49 $usepeak[34]=`y`
$peakppm[35]=1.455    $peakht[35]=5.6  $peakintnum[35]=7  $dres[35]=4.52 $usepeak[35]=`y`
$peakppm[36]=1.439    $peakht[36]=3.0  $peakintnum[36]=7  $dres[36]=32.87 $usepeak[36]=`y`
$peakppm[37]=1.056    $peakht[37]=50.8  $peakintnum[37]=8  $dres[37]=3.60 $usepeak[37]=`y`
$peakppm[38]=1.040    $peakht[38]=49.0  $peakintnum[38]=8  $dres[38]=3.63 $usepeak[38]=`y`
$peakppm[39]=1.017    $peakht[39]=51.0  $peakintnum[39]=8  $dres[39]=3.62 $usepeak[39]=`y`
$peakppm[40]=1.001    $peakht[40]=48.9  $peakintnum[40]=8  $dres[40]=3.62 $usepeak[40]=`y`

"Adjustments to integral setpoints for multiplets"
$fromfirstpeak[1]=10  $fromlastpeak[1]=10
$fromfirstpeak[2]=10  $fromlastpeak[2]=10
$fromfirstpeak[3]=10  $fromlastpeak[3]=10
$fromfirstpeak[4]=25  $fromlastpeak[4]=26
$fromfirstpeak[5]=10  $fromlastpeak[5]=10
$fromfirstpeak[6]=26  $fromlastpeak[6]=10
$fromfirstpeak[7]=10  $fromlastpeak[7]=10
$fromfirstpeak[8]=10  $fromlastpeak[8]=10
$maxpeakppm=7.487  $totalnumpeaks=40





" ************************************************ "

" Beginning of xxgf_append_quantmacros_output      "
" version 24 May 2011 by Patrick Hays            "
" ************************************************ "

" If $print_one_page=y then all information is on the spectrum page, "
" otherwise there are 2 pages: spectrum with insets and little text and another page with text with all information "

$print_one_page='y'  

" !!!!!!!!  set $printpeakht to y if you want peak height quants always printed !!!!!!!! "

$printpeakht='n'  $orig_print_ht='n'

if auto='y' then  
  $printpeakht='n' $orig_print_ht='y'
else 
  input('Do you want peak heights printed? '):$answer
  if $answer='y' then $printpeakht='y' $orig_print_ht='y'  endif
endif



ai intmod='partial' vp=12
lb='n' gf='n' 


$solvent=solvent
format(solvent,'upper'):$solvent
if $solvent='d2o' then $solvent='D2O' endif
if $solvent='cdcl3' then $solvent='CDCL3' endif
if $solvent='cd3od' then $solvent='CD3OD' endif
if $solvent='methanol' then $solvent='CD3OD' endif
if $solvent='chloroform' then $solvent='CDCL3' endif

" is the parameter volume present? if not create it "

$volume=''
exists('volume','parameter'):$e

  if $e=1 then 
    if volume<=0 then volume=1 endif
  else
    create('volume','real','current')
    volume=1
  endif

  format(volume,2,1):$volume


$searchwidth=0.04p "default search window- how far beyond the initial integral setpoints we search for peaks "

if $#=2 then
  if $1='searchwidth' then $searchwidth=$2 endif  " The value is in Hz "
endif

	" phase and set TSP to 0 ppm if in automation "

if auto='y' then
  rt(file)
  wft  setref tmsref
  dea_phasing('slow')
  f full vp=12 
  lb='n' gf='n' wft dc  ai ds
else
  input('Do you want autophasing? (y or n)'):$answer

    if $answer='y' then
      wft
      dea_phasing('slow')
      f full vp=12 
      lb='n' gf='n' wft dc  ai ds
    else
      f full vp=12 lb='n' gf='n' wft dc ai ds
    endif

endif

	" find noise region to use for signal to noise calculations "

$noise_vs=0
$noiseleft=-0.5p $noiseright=-1p " default region "
$dum=0
f full
sp=sp+0.5p wp=0.5p vsadj $dum=vs $noiseleft=sp+wp $noiseright=sp
sp=sp+wp vsadj if $dum<vs then $dum=vs $noiseleft=sp+wp $noiseright=sp endif
sp=sp+wp vsadj if $dum<vs then $dum=vs $noiseleft=sp+wp $noiseright=sp endif
sp=sp+wp vsadj if $dum<vs then $dum=vs $noiseleft=sp+wp $noiseright=sp endif
f full
sp=sp+wp-1p wp=0.5p vsadj if $dum<vs then $dum=vs $noiseleft=sp+wp $noiseright=sp endif
sp=sp-0.5p wp=0.5p vsadj if $dum<vs then $dum=vs $noiseleft=sp+wp $noiseright=sp endif
sp=sp-0.5p wp=0.5p vsadj if $dum<vs then $dum=vs $noiseleft=sp+wp $noiseright=sp endif
sp=sp-0.5p wp=0.5p vsadj if $dum<vs then $dum=vs $noiseleft=sp+wp $noiseright=sp endif

	" set integrals for baseline correction "

f full lb='n' gf='n' wft dc 
sp=$noiseright wp=0.5p vsadj vs=vs/100 $noise_vs=vs
th=4 
pickpeaks(25,32)    "pickpeaks can be used instead of hregions to define baseline correction integrals"
adjust_integrals('fast')
bc


" ************************************** "
" check the width of internal standard   "
" if >2.5 Hz then don't quantitate       "
" ************************************** "

$res=0  $height=0 
sp=$is_pos2 wp=$is_pos1-$is_pos2
vsadj peak:$height,cr dres:$res
$is_location=cr

if $res>2.5 then	" AAA "

  if auto='y' then	" BBB "
    f full vp=12
    $sampwt=''
    $iswt=''
    format(sampwt,4,3):$sampwt
    format(iswt,5,4):$iswt

    text(sampid)
    atext(file)
    atext(date)
    atext(soluble)
    atext('Varian '+Console+' 400 MHz NMR')
    deanumber
    atext(solvent+' with 0 ppm reference') 
    atext('sample weight: '+$sampwt+' mg')
    atext('Internal Std: '+$is_name+' weight: '+$iswt+' mg')
    atext('')
    atext('Internal Standard Peak is TOO WIDE FOR ACCURATE AUTOMATED QUANTITATION.')
    atext('Recommend diluting sample with solvent and rerun experiment.')
    atext('Manual integration may be used for approximation.')

    f full
    intmod='off'
    vp=12
    sp=0.5p wp=3.9p
    vsadj  $vs1=vs
    sp=4.9p wp=1.1p vsadj $vs2=vs
    sp=6.5p wp=4p vsadj $vs3=vs
    if $vs1<$vs2 then $vs_use=$vs1 else $vs_use=$vs2 endif
    if $vs_use>$vs3 then $vs_use=$vs3 endif
    vs=$vs_use
    sp=-0.1p wp=10.1p 


    " print on the page the location of internal standard and solvent peaks "

	if ($is_name='maleic') and (sp+wp>6.4*sfrq) and (sp<6.2*sfrq) then
		$istd_spot=(wp-(6.45*sfrq-sp))/wp*wcmax
		$istd_spot2=(wp-(6.2*sfrq-sp))/wp*wcmax
		write('plotter',$istd_spot,20,'<--')
		write('plotter',$istd_spot,23,'maleic acid (ISTD)')
	endif

	if ($is_name='dimethylfumarate') and (sp+wp>6.8*sfrq) and (sp<6.6*sfrq) then
		$istd_spot=(wp-(6.8*sfrq-sp))/wp*wcmax
		write('plotter',$istd_spot,30,'<--dimethylfumarate (ISTD)')
	endif

	if ($is_name='dimethylfumarate_4ppm') and (sp+wp>3.9*sfrq) and (sp<3.7*sfrq) then
		$istd_spot=(wp-(3.8*sfrq-sp))/wp*wcmax
		write('plotter',$istd_spot,40,'<--dimethylfumarate (ISTD)')
	endif

	if ($is_name='dimethylsulfone') and (sp+wp>3.1*sfrq) and (sp<3*sfrq) then
		$istd_spot=(wp-(3.1*sfrq-sp))/wp*wcmax
		write('plotter',$istd_spot,40,'<--dimethylsulfone (ISTD)')
	endif

	if ($solvent='D2O') and (sp+wp>4.8*sfrq) and (sp<4.7*sfrq) then
		$solvent_spot=(wp-(4.8*sfrq-sp))/wp*wcmax
		write('plotter',$solvent_spot,40,'<--HDO')
	endif

	if $solvent='CDCL3' and (sp+wp>7.1*sfrq) and (sp<7.2*sfrq) then
		$solvent_spot=(wp-(7.2*sfrq-sp))/wp*wcmax
		write('plotter',$solvent_spot,40,'<--from CDCl3')
	endif

	if ($solvent='CD3OD') and (sp+wp>4.8*sfrq) and (sp<4.7*sfrq) then
		$solvent_spot=(wp-(4.8*sfrq-sp))/wp*wcmax
		write('plotter',$solvent_spot,30,'<--from CD3OD')
	endif

	if ($solvent='CD3OD') and (sp+wp>3.3*sfrq) and (sp<3.3*sfrq) then
		$solvent_spot=(wp-(3.3*sfrq-sp))/wp*wcmax
		write('plotter',$solvent_spot,20,'<--from CD3OD')
	endif

	if  (sp+wp>-0.1*sfrq) and (sp<0.1*sfrq) then
		$solvent_spot=(wp-(0.1*sfrq-sp))/wp*wcmax
	  if $solvent='D2O' then
		write('plotter',$solvent_spot,25,'TSP')
	  else
		write('plotter',$solvent_spot,25,'TMS')
	  endif

	endif

    pap pl pscale 
    page
    return
  else
    write('line3','Width of internal standard is too large for qNMR macro.  Do manual integration.')
    return
  endif		" BBB "

endif		" AAA "


" ****************************************** "
" adjust internal standard peak to 3 Hz wide "
" ****************************************** "

fn=np*4 
lb='n'
gf=at/2
$resmax=3
$dum=0
$neg=3
f full wft bc sp=$is_location-40 wp=80 ds peak:$ht,cr $is_location=cr dres:r1
 
" internal standard peaks bigger than 2.5 Hz wide "
" indicate that either shimming did not work or   "
" there are paramagnetic substances in solution   "

if r1>2.5 then     write('line3','peak too wide with gf=at/2') 
  return 
endif 

" normalizing internal standard peak width to 3.000 Hz "

$a=1
repeat
  $neg=-10/3*$neg
  $b=0

  repeat
    vsadj peak:$ht,cr $is_location=cr  
    gf=gf+1/$neg wft bc nl dres:r1 ds 
    if r1>$resmax*0.9999 and r1<$resmax*1.0001 then $dum=$a $b=1 $a=100 endif
    if $neg>0 and r1<$resmax then $b=1 endif
    if $neg<0 and r1>$resmax then $b=1 endif
    if gf>at/2 then write('line3','gf>at/2') return endif
  until $b>0

  $a=$a+1
until $a>20

" check to see that the peak width was achieved "

if r1>1.001*$resmax or r1<0.999*$resmax then 
   write('line3','Internal Standard peak width will NOT normalize')
   return 
endif

$gf3=gf  " Gaussian value to achieve 3 Hz is saved "


" ************************************************************** "
	" *********** find noise region ***************** "

$noise_3Hz_vs=0
$noise_3Hzleft=-0.5p $noise_3Hzright=-1p " default region "
$dum=0
f full
sp=sp+0.5p wp=0.5p vsadj $dum=vs $noise_3Hzleft=sp+wp $noise_3Hzright=sp
sp=sp+wp vsadj if $dum<vs then $dum=vs $noise_3Hzleft=sp+wp $noise_3Hzright=sp endif
sp=sp+wp vsadj if $dum<vs then $dum=vs $noise_3Hzleft=sp+wp $noise_3Hzright=sp endif
sp=sp+wp vsadj if $dum<vs then $dum=vs $noise_3Hzleft=sp+wp $noise_3Hzright=sp endif
f full
sp=sp+wp-1p wp=0.5p vsadj if $dum<vs then $dum=vs $noise_3Hzleft=sp+wp $noise_3Hzright=sp endif
sp=sp-0.5p wp=0.5p vsadj if $dum<vs then $dum=vs $noise_3Hzleft=sp+wp $noise_3Hzright=sp endif
sp=sp-0.5p wp=0.5p vsadj if $dum<vs then $dum=vs $noise_3Hzleft=sp+wp $noise_3Hzright=sp endif
sp=sp-0.5p wp=0.5p vsadj if $dum<vs then $dum=vs $noise_3Hzleft=sp+wp $noise_3Hzright=sp endif

sp=$noise_3Hzright wp=0.5p vsadj 
vs=vs/100 th=10 ds          "threshhold set above noise region"
$noise_height=0	
peak:$noise_height,cr	"maximum noise height to be used in $sampmaxintht calc"
$noise_3Hz_vs=vs	
$numsamplepeaks=0
sp=0.5p wp=10p ds nll:$numsamplepeaks 	"all the peaks above noise"


" ******* discover peak positions and heights in sample ********* "

$htis=0
$minht=-1
f full
cr=$is_location
nl:$htis   "internal standard height "

$a=1    " Assign height and width of all spectrum peaks to variables "
repeat
	cr=llfrq[$a]+rfp-rfl
	sp=cr-30 wp=60 ds cr=llfrq[$a]+rfp-rfl nl:$ht  
	$dres_samp[$a]=0    dres:$dres_samp[$a]
	$pos_samp[$a]=cr/sfrq
	$height_samp[$a]=$ht 
        if $minht=-1 then $minht=$ht else
          if $minht>$ht then $minht=$ht endif
        endif
        f
	$a=$a+1
until $a>$numsamplepeaks


" ********** adjust vs to correspond with standard heights (tallest is 150) ********** "

	" set new variable " 

$a=1  "integral counter"
repeat
  $stdmaxintht[$a]=0	$stdminintht[$a]=10000000000
  $sampmaxintht[$a]=$minht	" set the sample maximum height in each integral to the lowest height obtained "
  $stdnumpeaks[$a]=0 	$sampnumpeaks[$a]=0	
  $firstsamplepeak[$a]=0  "sample peak # that is first in integral $a"
  $lastsamplepeak[$a]=0   "sample peak # that ends in integral $a"
  $firststdpeak[$a]=0
  $a=$a+1
until $a>$numintegrals

	"determine highest and lowest standard peak in each integral"

$dum=0 
$a=1 "integral counter"
repeat
  $counter=0
  $b=1 "standard peak counter"
  repeat
    $quant_ht[$b]=-1  "set this parameter for later use"
    $dum=$peakht[$b]
    if $peakppm[$b]>$intright[$a] and $peakppm[$b]<$intleft[$a] then
      $counter=$counter+1
      if $counter=1 then $firststdpeak[$a]=$b endif
      if $stdmaxintht[$a]<$dum then $stdmaxintht[$a]=$dum endif
      if $stdminintht[$a]>$dum then $stdminintht[$a]=$dum endif
    endif
    $b=$b+1
  until $b>$totalnumpeaks
  $stdnumpeaks[$a]=$counter
  $a=$a+1
until $a>$numintegrals


	"determine highest sample peak in each integral"

$dum=0 

$a=1 "integral counter"
repeat
  $b=1 "sample peak counter"
  repeat
    if $pos_samp[$b]>$intright[$a]-$searchwidth/sfrq and $pos_samp[$b]<$intleft[$a]+$searchwidth/sfrq then
      if $sampmaxintht[$a]<$height_samp[$b] then $sampmaxintht[$a]=$height_samp[$b] endif
    endif
    $b=$b+1
  until $b>$numsamplepeaks
  $a=$a+1
until $a>$numintegrals

	"determine correction factor ($ratio) needed to adjust sample spectrum "
	"so it corresponds with the standard spectrum heights                  "

$a=1  $ratio=0  $dum=0
repeat
  if $useint[$a]='y' then
    $dum=$stdmaxintht[$a]/$sampmaxintht[$a]

    if $ratio<$dum then $ratio=$dum endif

  endif
  $a=$a+1
until $a>$numintegrals



" !!!!!!!!!  test section to establish bad and good integral setpoints !!!!! "

$a=1  "integral counter"
repeat
  "setting good and bad integral setpoint variables"
  $correctnumpeaks[$a]='n'
  $left_good_integral[$a]=$intleft[$a]
  $right_good_integral[$a]=$intright[$a]
  $left_bad_integral[$a]=$intleft[$a]    "default bad setpoint"
  $right_bad_integral[$a]=$intright[$a]  "default bad setpoint"
  $left_test_integral[$a]=$intleft[$a]   " used to evaluate deviations from calibration table "
  $right_test_integral[$a]=$intright[$a]

  $c=0  "increment of searchwidth counter"
  $incrementwidth=$searchwidth/5/sfrq

  repeat
    $b=1 "sample peak counter"
    $firstsamplepeak[$a]=0 $lastsamplepeak[$a]=0  "defines sample peak numbers in an integral"
    $counter=0  "number of peaks that might relate to standard spectrum peaks"
    $dumfirst=0 $dumlast=0 $placemarker1=0 $placemarker2=0

    repeat
      if $pos_samp[$b]>$intright[$a]-$incrementwidth*$c and $pos_samp[$b]<$intleft[$a]+$incrementwidth*$c then
        if $dumfirst=0 and $placemarker1=0 then $placemarker1=$b endif
        if $dumfirst=0 then $placemarker2=$b endif
        if $height_samp[$b]*$ratio>$stdminintht[$a]*0.7 "and $height_samp[$b]*$ratio<$stdmaxintht[$a]*2" then
            $counter=$counter+1 
            if $firstsamplepeak[$a]=0 then 
               $firstsamplepeak[$a]=$b   $dumfirst=$b
               $left_test_integral[$a]=$pos_samp[$dumfirst]+$fromfirstpeak[$a]/sfrq
            endif
            $lastsamplepeak[$a]=$b  $dumlast=$b
            $right_test_integral[$a]=$pos_samp[$dumlast]-$fromlastpeak[$a]/sfrq

        endif
      endif
      $b=$b+1
    until $b>$numsamplepeaks

    if $dumfirst=0 then $dumfirst=$placemarker1 endif
    if $dumfirst=0 then $dumlast=$placemarker2 endif

    $sampnumpeaks[$a]=$counter

    if $counter=$stdnumpeaks[$a] then

      " we found a test group of peaks likely to be the analyte "

      $correctnumpeaks[$a]='y'
      $c=100
      $left_bad_integral[$a]=$left_test_integral[$a]
      $right_bad_integral[$a]=$right_test_integral[$a]
    else

      " we could not find an ideal group of analyte peaks, go with bad setpoints "  

      $left_bad_integral[$a]=$intleft[$a]+$incrementwidth*$c
      $right_bad_integral[$a]=$intright[$a]-$incrementwidth*$c
      $left_test_integral[$a]=$pos_samp[$dumfirst]+$fromfirstpeak[$a]/sfrq
      $right_test_integral[$a]=$pos_samp[$dumlast]-$fromlastpeak[$a]/sfrq
      if $left_test_integral[$a]>$left_bad_integral[$a] then $left_test_integral[$a]=$left_bad_integral[$a] endif
      if $right_test_integral[$a]<$right_bad_integral[$a] or $right_test_integral[$a]>$left_test_integral[$a] then 
        $right_test_integral[$a]=$right_bad_integral[$a]
      endif
      
    endif

    " if overlap occurs and we know that one of the setpoints is correct, then adjust the other set point "
	if $a>1 then
		if $right_bad_integral[$a-1]<>$right_test_integral[$a-1] and $left_bad_integral[$a]=$left_test_integral[$a] then
			if $left_test_integral[$a]>$right_test_integral[$a-1] then
				$right_test_integral[$a-1]=$left_test_integral[$a]
			endif
		endif
	endif
	if $a>1 then
		if $right_bad_integral[$a-1]=$right_test_integral[$a-1] and $left_bad_integral[$a]<>$left_test_integral[$a] then
			if $right_test_integral[$a-1]<$left_test_integral[$a] then
				$left_test_integral[$a]=$right_test_integral[$a-1]
			endif
		endif
	endif
	if $a>1 then
		if $right_bad_integral[$a-1]<>$right_test_integral[$a-1] and $left_bad_integral[$a]<>$left_test_integral[$a] then
			if $left_test_integral[$a]>$left_bad_integral[$a] then $left_test_integral[$a]=$left_bad_integral[$a] endif
			if $right_test_integral[$a-1]<$right_bad_integral[$a-1] then $right_test_integral[$a-1]=$right_bad_integral[$a-1] endif
		endif
	endif

    $c=$c+1
  until $c>5

  " test integral setpoints and then set the good_integral left and right accordingly "

  $test1=($left_test_integral[$a]-$right_test_integral[$a])-($left_good_integral[$a]-$right_good_integral[$a]) " difference in integral widths "
  $test2=$left_test_integral[$a]-$left_good_integral[$a]
  $test3=$right_good_integral[$a]-$right_test_integral[$a]
  if $test1<-20 or $test2<-1*$searchwidth or $test3<-1*$searchwidth then 
      $left_test_integral[$a]=$left_good_integral[$a] $right_test_integral[$a]=$right_good_integral[$a]
  endif
  if $a>1 then
    if $left_test_integral[$a]>$right_good_integral[$a-1] then $left_test_integral[$a]=$right_good_integral[$a-1] endif
  endif
  $left_good_integral[$a]=$left_test_integral[$a] $right_good_integral[$a]=$right_test_integral[$a] 

  $a=$a+1

until $a>$numintegrals


if $numintegrals>1 then
  $a=2
  repeat
    if $left_good_integral[$a]>$right_good_integral[$a-1] then 
        $left_good_integral[$a]=($left_good_integral[$a]+$right_good_integral[$a-1])/2 
        $right_good_integral[$a-1]=$left_good_integral[$a]
    endif
    $a=$a+1 
  until $a>$numintegrals-1
endif


	"determine peak height quants if #sample peaks = #std peaks in an integral"

$a=1  "integral number"
repeat
  if $sampnumpeaks[$a]=$stdnumpeaks[$a] then	" CCC "
    $b=$firstsamplepeak[$a]  "sample peak number"
    $c=$firststdpeak[$a]     "std peak number"
    repeat

      if $height_samp[$b]*$ratio>$stdminintht[$a]*0.7 and $height_samp[$b]*$ratio<$stdmaxintht[$a]*2 then

         if $dres_samp[$b]<$dreshi[$c] and $dres_samp[$b]>$dreslo[$c] and $usepeak[$c]=`y` then

            if ($A[$c]=0) and ($B[$c]=0) and ($C[$c]=0) then
              $quant_ht[$c]=$purity/100*iswt/sampwt*$pf[$c]*$height_samp[$b]/$htis
            else      
              $pf[$c]=$purity/100*$A[$c]*$dres_samp[$b]*$dres_samp[$b]+$purity/100*$B[$c]*$dres_samp[$b]+$purity/100*$C[$c]
              $quant_ht[$c]=iswt/sampwt*$pf[$c]*$height_samp[$b]/$htis
            endif

         endif
         $c=$c+1

      endif
      $b=$b+1
    until $b>$lastsamplepeak[$a]

  endif		" CCC "

  $a=$a+1
until $a>$numintegrals


	" finding heights that worked and assign them to $statht[$counter]"

$b=1
$counter=0

repeat
  if $quant_ht[$b]>0 then $counter=$counter+1 $statht[$counter]=$quant_ht[$b] endif
  $b=$b+1
until $b>$totalnumpeaks

$stathtcount=$counter



" ************************************** "
	"integration "
" ************************************** "


gf='n' lb='n' f full vp=12 wft dc
$vs=vs  vs=$noise_vs th=4 
pickpeaks(25,32)
adjust_integrals('mid')  bc cz

$dsn_int_min=1000000

$a=1   $vs_sample=0
repeat   " ABC "
  $dsn_integral[$a]=0 
  $dsn_MAD_int[$a]=0
  $textppm[$a]='' format(($left_good_integral[$a]+$right_good_integral[$a])/2,3,2):$textppm[$a]

  z($left_good_integral[$a]*sfrq,$right_good_integral[$a]*sfrq) 
  sp=$right_good_integral[$a]*sfrq wp=($left_good_integral[$a]-$right_good_integral[$a])*sfrq
  vsadj 

  if $vs_sample=0 then 
          $vs_sample=vs 
  else
          if $vs_sample>vs then $vs_sample=vs endif
  endif
         
  format(($left_good_integral[$a]+$right_good_integral[$a])/2,3,2):$textppm[$a]
  dsn($noiseleft,$noiseright):$dsn_integral[$a]
  if $dsn_int_min>$dsn_integral[$a] then $dsn_int_min=$dsn_integral[$a] endif
  $dsn_MAD_int[$a]=0.15+15/sqrt($dsn_integral[$a])

  f

  $a=$a+1
until $a>$numintegrals   " ABC "

"internal standard peak"

sp=$is_location-40 wp=80
vsadj $dum=0  peak:$dum,cr vs=vs*100/$dum th=2 
sp=$is_location-40 wp=80  dll:r1

r2=llfrq[1]-llfrq[r1]
if r2<10 then z($is_location+40,$is_location-40) 
  else z($is_location+10,$is_location-10)	
endif 

" reference or 0 ppm peak "

sp=-0.5p wp=1p peak:$dum,cr	"TSP or TMS"
$tms_location=cr
z($tms_location+40,$tms_location-40)

f full
adjust_integrals('slow')	"macro that moves integral set points away from peaks to flat baseline "
numreg:$numregions
$numberofintegrals=0  " number of analyte integrals "

	" setting variables "

$a=1
repeat
  $quant[$a]=-1
  $a=$a+1
until $a>$numintegrals

$tmsint=0
$dum=0
$intstdint=0



" ************************************************ "
" find the C13 satelite contributions to integrals "
" ************************************************ "

$c13satcorr='n'
ff intmod='partial' isadj is=is*100 intmod='full'
$a=1 "region counter"	$integralcounter=1
repeat
  getreg($a):r1,r2
  integ(r1,r2):$dum   r3=r1/sfrq r4=r2/sfrq

  $dum1=0 $dum2=0
  if dm='nnn' then
    integ(r1+65,r2+75):$dum1
    integ(r1-75,r2-65):$dum2
    if $dum1<0 then $dum1=0 endif
    if $dum2<0 then $dum2=0 endif
    if $solvent='D2O' and r4>4.5 and r4<5.05 then $dum1=0 $dum2=0 endif
    if $solvent='D2O' and r3>4.5 and r3<5.05 then $dum1=0 $dum2=0 endif
  endif

  $c13sat=($dum1+$dum2)*0.0055

  $dum_correct=$dum-$c13sat

  $correction=$dum_correct/$dum
  if $correction>1 then $correction=1 endif
  if $correction<1 and $correction>0.999 then $correction=1 endif

	$b=1	" find which analyte integral is represented by r1 and r2 "
	repeat
           $corrected_c13_text[$b]=''
           if r1<$is_location and r2>$is_location then 
                $intstdint=$dum_correct "set the internal standard integral value"
		$intstdcorrfactor=$correction
                $corrected_c13_istd='' 
                if $correction<>1 then 
                  $dumtext='' 
                  format($correction,5,4):$dumtext 
                  $corrected_c13_istd='(D) correction factor= '+$dumtext 
                  $c13satcorr='y'
                endif
                $region_num_intstd=$a
             else
		$quant[$integralcounter]=$dum_correct
                $correctionfactor[$integralcounter]=$correction
                if $correction<>1 then 
                  $dumtext='' 
                  format($correction,5,4):$dumtext 
                  $corrected_c13_text[$integralcounter]='(D) correction factor= '+$dumtext
                  $c13satcorr='y' 
                endif

		$integralcounter=$integralcounter+1
		$numberofintegrals=$numberofintegrals+1
		$b=$numintegrals
	   endif
	   $b=$b+1
	until $b>$numintegrals
 
  $setpoint1[$a]=r1
  $setpoint2[$a]=r2
  if r1<$tms_location and r2>$tms_location then $tmsint=$dum endif

  $a=$a+1
until $a>$numregions
intmod='partial'



	"calculating integral quants"

if $intstdint=0 or sampwt=0 then write('line3','Cannot use this macro for quantitation.') return endif

$min_int=-1  $min_int_number=-1

$a=1
repeat
  $quant_int[$a]=-1
  if $quant[$a]>0 and $useint[$a]='y' then 
    $quant_int[$a]=$quant[$a]/$intstdint*$is_num_H/$numH[$a]*iswt/sampwt*$mw/$is_mw*100
    if $min_int=-1 then $min_int=$quant_int[$a] $min_int_number=$a 
    else 
      if $min_int>$quant_int[$a] then $min_int=$quant_int[$a] $min_int_number=$a endif
    endif
  endif
  $a=$a+1
until $a>$numintegrals   "$numberofintegrals"



" convert individual relative MAD values to absolute MAD values based on quant value "

$a=1
repeat
  $dsn_MAD_int[$a]=$dsn_MAD_int[$a]*$quant_int[$a]/100
  $a=$a+1
until $a>$numintegrals

" find lowest $quant_int+4*$dsn_MAD_int value that still encompasses $min_int "

$lowest_hi_limit=1000

$a=1
repeat
  if $quant_int[$a]>0 then
    if $lowest_hi_limit>($quant_int[$a]+4*$dsn_MAD_int[$a]) then 
      $lowest_hi_limit=($quant_int[$a]+4*$dsn_MAD_int[$a])
    endif
  endif
  $a=$a+1
until $a>$numintegrals

$counter=0   
" $filtered[$counter] is the quant value that makes it through the MAD test "

$a=1  $MAD_int_min=10000
repeat
  if ($quant_int[$a]>0) and ($quant_int[$a]<$lowest_hi_limit) and (($quant_int[$a]-4*$dsn_MAD_int[$a])<=$min_int) and ($dsn_integral[$a]>20) then
    $counter=$counter+1
    $filtered[$counter]=$quant_int[$a]
    if $MAD_int_min>$dsn_MAD_int[$a] then $MAD_int_min=$dsn_MAD_int[$a] endif
  endif
  $a=$a+1
until $a>$numintegrals

$num_passed_int=$counter

$MAD_int=$MAD_int_min
$ave_int=0
$stdev_int=0
$sum_int=0 
$max_final_int=0
$MAD_int_defined='MAD based on smallest S/N'  "how was $MAD_int determined "

if $num_passed_int>1 then

  $midpt=trunc($num_passed_int/2)
  sort($filtered):$order,$values   "sorts the array $filtered"

  if $midpt=$num_passed_int/2 then
    $median=$filtered[$order[$midpt]]
  else
    $median=($filtered[$order[$midpt]]+$filtered[$order[$midpt+1]])/2
  endif

  $a=1
  repeat
    $diff_int[$a]=0 abs($filtered[$a]-$median):$diff_int[$a]
    $a=$a+1
  until $a>$num_passed_int

  sort($diff_int):$order,$values
  if $midpt=$num_passed_int/2 then
    $MAD_int=$diff_int[$order[$midpt]]*1.4826  "determines MAD for this data "
  else
    $MAD_int=($diff_int[$order[$midpt]]+$diff_int[$order[$midpt+1]])/2*1.4826
  endif

  $MAD_int_defined='MAD based on non-outlier data'

  " $MAD_int is set to median absolute deviation of non-outlier data "
  " then adjusted if this is smaller than default minimum "
  " or the smallest non-outlier S/N MAD value "

  if $MAD_int<(0.15*$min_int/100) then " wont go lower than the reasonable $MAD_int limit "
    $MAD_int=(0.15*$min_int/100) 
    $MAD_int_defined='MAD based on minimum allowed value'
  endif  

  if $MAD_int<$MAD_int_min then " adjust $MAD_int if it is lower than the largest MAD value "
    $MAD_int=$MAD_int_min
    $MAD_int_defined='MAD based on smallest S/N'
  endif  

  $a=1  $min_z=10000
  repeat
    $z_score[$a]=($filtered[$a]-$median)/$MAD_int
    if $min_z>$z_score[$a] then $min_z=$z_score[$a] endif
    $a=$a+1
  until $a>$num_passed_int
  $adjust_z=-2-($min_z)  " this will move lowest z-score to -2 "

  $a=1 $counter=0 
  repeat
    $dum=$z_score[$a]+$adjust_z
    if $dum<2 then 
      $counter=$counter+1 $final_int[$counter]=$filtered[$a] 
      if $max_final_int<$final_int[$counter] then $max_final_int=$final_int[$counter] endif
      $sum_int=$sum_int+$final_int[$counter]
    endif
    $a=$a+1
  until $a>$num_passed_int

  $num_passed_int=$counter
  $ave_int=$sum_int/$num_passed_int

	" calculating the standard deviation of integrals that pass z*-score<2 "

  $sum_diffsquared_int=0 

  if $ave_int>0 and $num_passed_int>1 then

    $a=1	
    repeat
      $diff_int_squared[$a]=0
      $diff_int_squared[$a]=($final_int[$a]-$ave_int)*($final_int[$a]-$ave_int)
      $sum_diffsquared_int=$sum_diffsquared_int+$diff_int_squared[$a]
      $a=$a+1
    until $a>$num_passed_int

    $stdev_int=sqrt($sum_diffsquared_int/($num_passed_int-1)) 

  else
    $stdev_int=0
  endif

  $text_stdev_int=''  

  if $stdev_int>0 then 
     if $stdev_int<0.1 then $stdev_int=0.1 endif
     if $ave_int>1 then format($stdev_int,3,2):$text_stdev_int else format($stdev_int,4,3):$text_stdev_int endif
  else
    $text_stdev_int='' 
  endif

else $max_final_int=$min_int
endif


" ************************************************************** "
	"********* Height Calculations ***********"
" ************************************************************** "

	" sort the peak heights that got a quant_ht value to them "

$a=1  $min_ht=10000
repeat
  $dsn_MAD_ht[$a]=(0.2+60/sqrt($dsn_integral[$peakintnum[$a]]))
  if $quant_ht[$a]>0 then
    if $min_ht>$quant_ht[$a] then $min_ht=$quant_ht[$a] endif
  endif
  $a=$a+1
until $a>$totalnumpeaks

" adjust MAD for height from relative to absolute value "

$a=1
repeat
  $dsn_MAD_ht[$a]=$dsn_MAD_ht[$a]*$min_ht/100
  $a=$a+1
until $a>$totalnumpeaks


" find lowest $quant_ht+4*$dsn_MAD_ht value that still encompasses $min_ht "

$lowest_hi_limit=1000

$a=1
repeat
  if $quant_ht[$a]>0 then
    if $lowest_hi_limit>($quant_ht[$a]+4*$dsn_MAD_ht[$a]) then 
      $lowest_hi_limit=($quant_ht[$a]+4*$dsn_MAD_ht[$a])
    endif
  endif
  $a=$a+1
until $a>$totalnumpeaks

$counter=0   
" $filtered[$counter] is the quant value that makes it through the MAD test "

$a=1  $MAD_ht_min=10000
repeat
  if ($quant_ht[$a]>0) and ($quant_ht[$a]<$lowest_hi_limit) and (($quant_ht[$a]-4*$dsn_MAD_ht[$a])<=$min_ht) and ($dsn_integral[$peakintnum[$a]]>20) then
    $counter=$counter+1
    $filtered[$counter]=$quant_ht[$a]
    if $MAD_ht_min>$dsn_MAD_ht[$a] then $MAD_ht_min=$dsn_MAD_ht[$a] endif
  endif
  $a=$a+1
until $a>$totalnumpeaks

$num_passed_ht=$counter

$MAD_ht=0
$MAD_ht_defined=''
$ave_ht=0
$stdev_ht=0
$sum_ht=0  
$max_final_ht=0
$text_stdev_ht='' 

if $num_passed_ht>1 then

  $midpt=trunc($num_passed_ht/2)
  sort($filtered):$order,$values   "sorts the array $filtered"
  $median=$filtered[$order[$midpt]]

  if $midpt=$num_passed_ht/2 then
    $median=$filtered[$order[$midpt]]
  else
    $median=($filtered[$order[$midpt]]+$filtered[$order[$midpt+1]])/2
  endif

  $a=1
  repeat
    $diff_ht[$a]=0 abs($filtered[$a]-$median):$diff_ht[$a]
    $a=$a+1
  until $a>$num_passed_ht

  sort($diff_ht):$order,$values

  if $midpt=$num_passed_ht/2 then
    $MAD_ht=$diff_ht[$order[$midpt]]*1.4826  "determines MAD for this data "
  else
    $MAD_ht=($diff_ht[$order[$midpt]]+$diff_ht[$order[$midpt+1]])/2*1.4826
  endif
  $MAD_ht_defined='MAD based on non-outlier data'

  if $MAD_ht<(0.2*$min_ht/100) then 
    $MAD_ht=(0.2*$min_ht/100)
    $MAD_ht_defined='MAD based on minimum allowed value'
  endif  " wont go lower than the reasonable $MAD_ht limit "

  if $MAD_ht<$MAD_ht_min then 
    $MAD_ht=$MAD_ht_min 
    $MAD_ht_defined='MAD based on smallest S/N'
  endif  

  $a=1  $min_z=10000
  repeat
    $z_score[$a]=($filtered[$a]-$median)/$MAD_ht
    if $min_z>$z_score[$a] then $min_z=$z_score[$a] endif
    $a=$a+1
  until $a>$num_passed_ht
  $adjust_z=-2-($min_z)  " this will move lowest z-score to -2 "

  $a=1 $counter=0 
  repeat
    $dum=$z_score[$a]+$adjust_z
    if $dum<2 then 
      $counter=$counter+1 $final_ht[$counter]=$filtered[$a] 
      if $max_final_ht<$final_ht[$counter] then $max_final_ht=$final_ht[$counter] endif
      $sum_ht=$sum_ht+$final_ht[$counter]
    endif
    $a=$a+1
  until $a>$num_passed_ht

  $num_passed_ht=$counter
  $ave_ht=$sum_ht/$num_passed_ht

	" calculating the standard deviation of heights that pass z*-score<2 "

  $sum_diffsquared_ht=0 

  if $ave_ht>0 and $num_passed_ht>1 then

    $a=1	
    repeat
      $diff_ht_squared[$a]=0
      $diff_ht_squared[$a]=($final_ht[$a]-$ave_ht)*($final_ht[$a]-$ave_ht)
      $sum_diffsquared_ht=$sum_diffsquared_ht+$diff_ht_squared[$a]
      $a=$a+1
    until $a>$num_passed_ht

    $stdev_ht=sqrt($sum_diffsquared_ht/($num_passed_ht-1)) 

  else
    $stdev_ht=0
  endif

 

  if $stdev_ht>0 then 
    if $stdev_ht<0.1 then $stdev_ht=0.1 endif
    if $ave_ht>1 then format($stdev_ht,3,2):$text_stdev_ht else format($stdev_ht,4,3):$text_stdev_ht endif
  else
    $text_stdev_ht='' 
  endif

elseif $num_passed_ht=1 then $ave_ht=$filtered[1]

endif

if $num_passed_int<3 and $orig_print_ht='y' then $printpeakht='y' endif

$text_ave_int=''  
if $num_passed_int>0 then 
    if $ave_int>1 then 
      format($ave_int,3,2):$text_ave_int 
      format($stdev_int,3,2):$text_stdev_int 
    else
      format($ave_int,4,3):$text_ave_int
      format($stdev_int,4,3):$text_stdev_int 
    endif
 else
    $ave_int=-1 
endif

if $ave_int<0 then 
  $ave_int=$min_int  format($ave_int,3,2):$text_ave_int 
endif

$text_ave_ht=''  
$text_stdev_ht='' 
if $num_passed_ht>0 then 
    if $ave_ht>1 then 
      format($ave_ht,3,2):$text_ave_ht 
      format($stdev_ht,3,2):$text_stdev_ht 
    else
      format($ave_ht,4,3):$text_ave_ht
      format($stdev_ht,4,3):$text_stdev_ht 
    endif
 else
    $ave_ht=-1 
endif

if $ave_ht<0 then 
  $ave_ht=$min_ht  format($ave_ht,3,2):$text_ave_ht 
endif


$text_num_int=''  format($num_passed_int,1,0):$text_num_int
$text_num_ht=''   format($num_passed_ht,1,0):$text_num_ht


" ************************************************ "
	" put the data in the text field "
" ************************************************ "

f full vp=12
$sampwt=''
$iswt=''
format(sampwt,4,3):$sampwt
format(iswt,5,4):$iswt

text(sampid)
atext(file)
atext(date)
if $macroname='' then
  atext('Process macro: dea_'+$name+'_'+$solvent+'_'+$is_name)
  atext('Quantitation Method: NMR-'+$is_name+'/'+$solvent)
else
  atext('Process macro: '+$macroname)
  atext('Quantitation Method: NMR-'+$is_name+'/'+$solvent)
endif
atext(soluble)
atext('Varian '+Console+' 400 MHz NMR')
deanumber
atext(solvent+' with 0 ppm reference') 
atext('sample weight: '+$sampwt+' mg')
$is_mw_text='' format($is_mw,3,2):$is_mw_text
$is_num_H_text='' format($is_num_H,1,0):$is_num_H_text

atext('Internal Std: '+$is_name+' (MW= '+$is_mw_text+', #H= '+$is_num_H_text+'), weight: '+$iswt+' mg')

if $is_name='maleic' then maleic_lot endif
if $is_name='dimethylsulfone' then dimethylsulfone_lot endif
if ($is_name='dimethylfumarate') or ($is_name='dimethylfumarate_4ppm') then dimethylfumarate_lot endif

atext('volume: '+$volume+' mL')
$istdcorrtext='' format($intstdcorrfactor,4,3):$istdcorrtext
atext('internal standard correction factor= '+$istdcorrtext)



atext('')
$text_totalnumintegrals='' format($numintegrals,1,0):$text_totalnumintegrals
$text_totalnumheights='' format($totalnumpeaks,1,0):$text_totalnumheights

" if the lowest signal to noise is below 10 for an integral, the chemist should use a higher concentration or more scans "

if $dsn_int_min<20 then
  atext('         SIGNAL TO NOISE RATIOS ARE LOW             ')  
  atext('YOU MUST CONFIRM THAT INTEGRALS ARE SET PROPERLY AND')
  atext('   THAT THE COMPOUND IS PRESENT BY OTHER METHODS    ')
  atext('')
endif

" check for possible pH increase due to sample matrix "

  if $is_name='maleic' then
    if $is_location/sfrq<6.3 then 
      atext('')
      atext(' !!!!!!!!!!!Warning!!!!!!!!!!!!!!!!!!') 
      atext('Maleic acid peak at less than 6.3 ppm ')
      atext('may indicate the presence of base in sample') 
      atext('which could affect solubility.')
    endif
  endif


" see if the average integral is in range with height value "

$intA=$ave_int+$MAD_int*2
$intB=$ave_int-$MAD_int*2
$htC=$ave_ht+$MAD_ht*2
$htD=$ave_ht-$MAD_ht*2

$overlap=0
" if overlap between integral and height then $overlap>0 "
if $intA>=$htC and $intB<=$htC then $overlap=$overlap+1 endif
if $intA>=$htD and $intB<=$htD then $overlap=$overlap+1 endif
if $intA<=$htC and $intA>=$htD then $overlap=$overlap+1 endif
if $intB<=$htC and $intB>=$htD then $overlap=$overlap+1 endif

if $overlap=0  then 
      if $ave_int>$ave_ht and $orig_print_ht='y' then $printpeakht='y' endif
      atext('***EXAMINE SPECTRUM CAREFULLY***')
endif

$mw_text='' format($mw,3,2):$mw_text
atext($name+'  MW= '+$mw_text)
atext('')

" Check solubility limit "

$conc=0 $dumtext='' $volumeneeded=0
$conc=sampwt*$min_int/100/volume  format($solubility,2,1):$dumtext
if $solubility>0 and $conc>$solubility*0.8 then 
  atext('***WARNING!! AT OR NEAR SOLUBILITY LIMIT OF '+$dumtext+' mg/mL ***')
  $volumeneeded=sampwt/$solubility+1  format($volumeneeded,1,0):$dumtext
  atext('If sample is pure '+$name+',')
  atext('you would need '+$dumtext+' mL to be fully soluble.')
  atext('Reweigh sample and reduce the concentration.')
  atext('')
endif

if $num_passed_int<=1 then 
    if $orig_print_ht='y' then $printpeakht='y' endif
    $text_min_int='' 
    if $min_int>1 then format($min_int,3,2):$text_min_int else format($min_int,4,3):$text_min_int endif

    if $num_passed_ht<3 then 
       atext('INTEGRAL MINIMUM RESULT: '+$text_min_int+'% (EXAMINE SPECTRUM CAREFULLY)') 
    else
       if $overlap>0 then atext('INTEGRAL MINIMUM RESULT: '+$text_min_int+'%') 
         else atext('INTEGRAL MINIMUM RESULT: '+$text_min_int+'% (EXAMINE SPECTRUM CAREFULLY)') 
       endif
    endif
endif

if $num_passed_int=2 and $overlap>0 then  
  if $num_passed_ht>2 then
    atext('Integral result: '+$text_ave_int+' +/-'+$text_stdev_int+'% ('+$text_num_int+' of '+$text_totalnumintegrals+' integrals)')
  else
    atext('Integral result: '+$text_ave_int+' +/-'+$text_stdev_int+'% ('+$text_num_int+' of '+$text_totalnumintegrals+' integrals) (EXAMINE SPECTRUM CAREFULLY)')
    if $orig_print_ht='y' then $printpeakht='y' endif
  endif
endif

if $num_passed_int=2 and $overlap=0 then
    if $orig_print_ht='y' then $printpeakht='y' endif
    atext('Integral result: '+$text_ave_int+' +/-'+$text_stdev_int+'% ('+$text_num_int+' of '+$text_totalnumintegrals+' integrals) (EXAMINE SPECTRUM CAREFULLY)')
endif

if $num_passed_int>2 and $overlap>0 then
  if $num_passed_ht<3 then
      atext('Integral result: '+$text_ave_int+' +/-'+$text_stdev_int+'% ('+$text_num_int+' of '+$text_totalnumintegrals+' integrals) (EXAMINE SPECTRUM CAREFULLY)')
  else
      atext('Integral result: '+$text_ave_int+' +/-'+$text_stdev_int+'% ('+$text_num_int+' of '+$text_totalnumintegrals+' integrals)')
  endif
endif

if $num_passed_int>2 and $overlap=0 then
      if $ave_int>$ave_ht and $orig_print_ht='y'  then $printpeakht='y' endif
      atext('Integral result: '+$text_ave_int+' +/-'+$text_stdev_int+'% ('+$text_num_int+' of '+$text_totalnumintegrals+' integrals) (EXAMINE SPECTRUM CAREFULLY)')
endif

$text_multform=''

atext('Integral results:')

$a=1
repeat
  $textdsn=''  $textz=''  $textused=''
  $text_hydrogens=''  format($numH[$a],5,4):$text_hydrogens
  $dum=trunc($numH[$a])
  if $dum<>$numH[$a] then
      if $multipleform='y' then $text_multform='(C)' endif
  else
      $text_multform=''
  endif
  if $quant_int[$a]<=$max_final_int and $dsn_integral[$a]>20 then $textz='' $textused=' * ' endif
  if $dsn_integral[$a]<20 then $textdsn='(B)'  endif
  if $quant_int[$a]>$max_final_int then $textz='(A)' endif

  if $useint[$a]='y' then 
        $textpercent='' 
        if $quant_int[$a]>1 then format($quant_int[$a],5,2):$textpercent else format($quant_int[$a],4,3):$textpercent endif
        if $quant_int[$a]<=0 then $textpercent='Cannot Use' endif
        atext($textppm[$a]+' ppm ('+$text_hydrogens+'H): '+$textpercent+'% '+$textused+$textz+$textdsn+$text_multform+' '+$corrected_c13_text[$a])
  endif

  if $useint[$a]<>'y' then atext($textppm[$a]+' ppm (not acceptable for quantitation)') endif

  $a=$a+1
until $a>$numintegrals

atext('LEGEND')
atext(' * :  used in reported result')
atext('(A):  result is a statistical outlier')
atext('(B):  Signal-to-Noise ratio <20')
if $multipleform='y' then atext('(C): multiple forms in solution, # H from calibration spectrum') endif
if $c13satcorr='y' then atext('(D): C13 satellites of nearby peaks considered in')
                        atext('     final quantitation result using correction factor shown.') endif

$MAD_int_text=''  
format($MAD_int,3,2):$MAD_int_text
atext('Median Absolute Deviation (MAD) value for integrals is '+$MAD_int_text+'%')
atext($MAD_int_defined)
atext('')

atext('')

if $printpeakht='y' and $num_passed_ht>0 then 
  if $overlap>0 and $num_passed_ht>2 then atext('Integral and Peak Height Results Agree') atext('') endif
  if $overlap>0 and $num_passed_ht<3 then atext('Examine Data Carefully') endif
  if $overlap=0 and $ave_int>$ave_ht then atext('Integral and Peak Height Results DO NOT AGREE') atext('') endif
endif

if $printpeakht='y' and $num_passed_ht>0 then
  atext('Peak height results (used to support reported integral results):')
  atext('Height Results  : '+$text_ave_ht+' +/-'+$text_stdev_ht+'% ('+$text_num_ht+' of '+$text_totalnumheights+' heights)')
  $a=1
  repeat
    $textz=''  $textppm[$a]=''   $textused='' 

    if $quant_ht[$a]<=$max_final_ht then 	" peaks with $quant_ht>$max_final_ht will not be printed "
        $textz='' 
        $textused=' * '
        if $quant_ht[$a]>0 and $usepeak[$a]='y' then 
          format($peakppm[$a],3,2):$textppm[$a]
          $textpercent=''  if $quant_ht[$a]>1 then format($quant_ht[$a],3,2):$textpercent else format($quant_ht[$a],4,3):$textpercent endif
          atext($textppm[$a]+' ppm: '+$textpercent+'% '+$textused+$textz)
        endif
    else
        $textused=''
        if $quant_ht[$a]>0 and $usepeak[$a]='y' then 
          format($peakppm[$a],3,2):$textppm[$a]
          $textpercent=''  if $quant_ht[$a]>1 then format($quant_ht[$a],3,2):$textpercent else format($quant_ht[$a],4,3):$textpercent endif
          atext($textppm[$a]+' ppm: '+$textpercent+'% '+$textused+$textz)
        endif
    endif

    $a=$a+1
  until $a>$totalnumpeaks

  atext('LEGEND')
  atext(' * :  used in height average')
$MAD_ht_text=''  
format($MAD_ht,3,2):$MAD_ht_text
atext('Median Absolute Deviation (MAD) value for heights is '+$MAD_ht_text+'%')
atext($MAD_ht_defined)
atext('')

endif

if $num_passed_ht=0 then 
  atext('***** NO PEAK HEIGHTS AVAILABLE FOR USE *****') 
  if $num_passed_int<3 then atext('***** INTEGRAL RESULT CAN ONLY BE USED AS AN APPROXIMATION *****') endif
  atext('') 
endif

$dum=20/$dsn_int_min
$dum_scans=nt*$dum*$dum  $text_scans='' format($dum_scans,1,0):$text_scans
$dum_conc=$dum $text_conc='' format($dum,2,1):$text_conc

if $dsn_int_min<20 then
  atext('Low Signal-to-Noise: consider increasing concentration by '+$text_conc+' times')
  atext('         or number of scans to '+$text_scans)
endif
	" checking the worthiness of the integral setpoints "

$a=1
repeat
  $integral_problems[$a]=''
  integ($setpoint1[$a],$setpoint1[$a]+5):r1
  integ($setpoint2[$a]-5,$setpoint2[$a]):r2
  integ($setpoint1[$a],$setpoint2[$a]):r3
  abs(r1+r2):r4
  if r3=0 then r3=0.0000001 write('line3','r3=0') endif
  r5=r4/r3 

  if r5>0.05 then  "if true there are possible problems with integral, bc, or ph "
    $dumtext='' format(($setpoint1[$a]+$setpoint2[$a])/2/sfrq,3,2):$dumtext
    $dumtext='***Visually check '+$dumtext+' ppm integral***' 
    atext($dumtext)
  endif
  $a=$a+1
until $a>$numregions

if $tmsint=0 then $tmsint=0.0000001 write('line3','$tmsint=0')  endif
$ratio_is_tms=$intstdint/$tmsint
$text_ratio=''  format($ratio_is_tms,4,3):$text_ratio
atext('Ratio of internal standard to 0 ppm reference peak: '+$text_ratio)



" **************************************** "
	" plotting spectrum "
" **************************************** "

if $print_one_page<>'y' then
  printon text printoff
  text(sampid)
  atext(file)
  atext(date)
  atext('Process macro: dea_'+$name+'_'+$solvent+'_'+$is_name)
  atext(soluble)
  atext('Varian '+Console+' 400 MHz NMR')
  deanumber
  atext(solvent+' with 0 ppm reference') 
  atext('sample weight: '+$sampwt+' mg')
  $is_mw_text='' format($is_mw,3,2):$is_mw_text
  $is_num_H_text='' format($is_num_H,1,0):$is_num_H_text
  atext('Internal Std: '+$is_name+' (MW= '+$is_mw_text+', #H= '+$is_num_H_text+'), weight: '+$iswt+' mg')
  if $is_name='maleic' then maleic_lot endif
  if $is_name='dimethylsulfone' then dimethylsulfone_lot endif
  if ($is_name='dimethylfumarate') or ($is_name='dimethylfumarate_4ppm') then dimethylfumarate_lot endif
  atext('volume: '+$volume+' mL')
  atext('')
  if $dsn_int_max<30 then
    atext('****RESULTS CAN ONLY BE USED AS AN APPROXIMATION****')
    atext('         SIGNAL TO NOISE RATIOS ARE LOW             ')  
    atext('YOU MUST CONFIRM THAT INTEGRALS ARE SET PROPERLY AND')
    atext('   THAT THE COMPOUND IS PRESENT BY OTHER METHODS    ')
    atext('')
  endif

  if $dsn_int_min<20 then
    atext('LOW SIGNAL-TO-NOISE RATIO FOR SOME INTEGRALS')
    atext('')
  endif

  if $overlap=0  then 
      if $orig_print_ht='y' then $printpeakht='y' endif
      atext('***EXAMINE SPECTRUM CAREFULLY***') atext('')
  endif

  $conc=0 $dumtext='' $volumeneeded=0
  $conc=sampwt*$min_int/100/volume  format($solubility,2,1):$dumtext

  if $solubility>0 and $conc>$solubility*0.8 then 
    atext('***WARNING!! AT OR NEAR SOLUBILITY LIMIT OF '+$dumtext+' mg/mL ***')
    atext('')
  endif

  atext($name+'  MW= '+$mw_text)
  atext('')

  if $num_passed_int<=1 then 
    if $num_passed_ht<3 then 
       atext('INTEGRAL MINIMUM RESULT: '+$text_min_int+'% (EXAMINE SPECTRUM CAREFULLY)') 
    else
       if $overlap>0 then atext('INTEGRAL MINIMUM RESULT: '+$text_min_int+'% ') 
         else atext('INTEGRAL MINIMUM RESULT: '+$text_min_int+'% (EXAMINE SPECTRUM CAREFULLY)') 
       endif
    endif
  endif

  if $num_passed_int=2 and $overlap>0 then  
    if $num_passed_ht>2 then
      if $orig_print_ht='y' then $printpeakht='y' endif
      atext('Integral result: '+$text_ave_int+' +/-'+$text_stdev_int+'% ('+$text_num_int+' of '+$text_totalnumintegrals+' integrals) ')
    else
      atext('Integral result: '+$text_ave_int+' +/-'+$text_stdev_int+'% ('+$text_num_int+' of '+$text_totalnumintegrals+' integrals) (EXAMINE SPECTRUM CAREFULLY)')
    endif
  endif

  if $num_passed_int=2 and $overlap=0 then
    if $orig_print_ht='y' then $printpeakht='y' endif
    atext('Integral result: '+$text_ave_int+' +/-'+$text_stdev_int+'% ('+$text_num_int+' of '+$text_totalnumintegrals+' integrals) (EXAMINE SPECTRUM CAREFULLY)')
  endif

  if $num_passed_int>2 and $overlap>0 then
    if $num_passed_ht<3 then
      if $orig_print_ht='y' then $printpeakht='y' endif
      atext('Integral result: '+$text_ave_int+' +/-'+$text_stdev_int+'% ('+$text_num_int+' of '+$text_totalnumintegrals+' integrals) (EXAMINE SPECTRUM CAREFULLY)')
    else
      atext('Integral result: '+$text_ave_int+' +/-'+$text_stdev_int+'% ('+$text_num_int+' of '+$text_totalnumintegrals+' integrals)')
    endif
  endif

  if $num_passed_int>2 and $overlap=0 then
      atext('Integral result: '+$text_ave_int+' +/-'+$text_stdev_int+'% ('+$text_num_int+' of '+$text_totalnumintegrals+' integrals) (EXAMINE SPECTRUM CAREFULLY)')
  endif

endif  " end of the IF THEN for having 2 pages printed- one page of text and one of spectrum "



f full vp=12  intmod='partial'

if $vs_sample<$noise_vs/10 then vs=$vs_sample*0.75 isadj 
else vs=$noise_vs/10 isadj
endif

if $solvent='D2O' or $solvent='d2o' then 
  sp=-0.1p wp=10.1p 
else
  sp=-0.1p wp=12p
endif

setint($region_num_intstd,100)
setint($region_num_intstd,100)
ds dpir

pscale cutoff=120 pl cutoff='n' pir 


    " print on the page the location of internal standard and solvent peaks "

if ($is_name='maleic') and (sp+wp>6.4*sfrq) and (sp<6.2*sfrq) then
	$istd_spot=(wp-(6.45*sfrq-sp))/wp*wcmax
	$istd_spot2=(wp-(6.2*sfrq-sp))/wp*wcmax
	write('plotter',$istd_spot,40,'<--')
	write('plotter',$istd_spot,43,'maleic acid (ISTD)')
endif

if ($is_name='dimethylfumarate') and (sp+wp>6.8*sfrq) and (sp<6.6*sfrq) then
	$istd_spot=(wp-(6.8*sfrq-sp))/wp*wcmax
	write('plotter',$istd_spot,40,'<--dimethylfumarate (ISTD)')
endif

if ($is_name='dimethylfumarate_4ppm') and (sp+wp>3.9*sfrq) and (sp<3.7*sfrq) then
	$istd_spot=(wp-(3.8*sfrq-sp))/wp*wcmax
	write('plotter',$istd_spot,40,'<--dimethylfumarate (ISTD)')
endif

if ($is_name='dimethylsulfone') and (sp+wp>3.1*sfrq) and (sp<3*sfrq) then
	$istd_spot=(wp-(3.1*sfrq-sp))/wp*wcmax
	write('plotter',$istd_spot,40,'<--dimethylsulfone (ISTD)')
endif

if ($is_name='methenamine') and (sp+wp>4.8*sfrq) and (sp<4.6*sfrq) then
	$istd_spot=(wp-(4.7*sfrq-sp))/wp*wcmax
	write('plotter',$istd_spot,40,'<--methenamine (ISTD)')
endif

if ($solvent='D2O') and (sp+wp>4.8*sfrq) and (sp<4.7*sfrq) then
	$solvent_spot=(wp-(4.8*sfrq-sp))/wp*wcmax
	write('plotter',$solvent_spot,30,'<--HDO')
endif

if $solvent='CDCL3' and (sp+wp>7.1*sfrq) and (sp<7.2*sfrq) then
	$solvent_spot=(wp-(7.2*sfrq-sp))/wp*wcmax
	write('plotter',$solvent_spot,30,'<--from CDCl3')
endif

if ($solvent='CD3OD') and (sp+wp>4.8*sfrq) and (sp<4.7*sfrq) then
	$solvent_spot=(wp-(4.8*sfrq-sp))/wp*wcmax
	write('plotter',$solvent_spot,30,'<--from CD3OD')
endif

if ($solvent='CD3OD') and (sp+wp>3.3*sfrq) and (sp<3.3*sfrq) then
	$solvent_spot=(wp-(3.3*sfrq-sp))/wp*wcmax
	write('plotter',$solvent_spot,25,'<--from CD3OD')
endif

if  (sp+wp>-0.1*sfrq) and (sp<0.1*sfrq) then
	$solvent_spot=(wp-(0.1*sfrq-sp))/wp*wcmax
  if $solvent='D2O' then
	write('plotter',$solvent_spot,25,'TSP')
  else
	write('plotter',$solvent_spot,25,'TMS')
  endif
endif

	" put insets in place "

vp=140  sc=105 wc=20 $vp=140
$a=1

repeat
  if sc<=0 then sc=105 vp=vp-20 endif
  sp=$setpoint1[$a] wp=$setpoint2[$a]-$setpoint1[$a] $vp=vp vp=145 vsadj io=2 isadj vp=$vp 
  $dum=0  dsn($noiseleft,$noiseright):$dum  if $dum<30 then vs=vs/3 endif
  sp=sp-10 wp=wp+20 pl pscale
  sc=sc-wc vp=vp-5
  $a=$a+1
until $a>$numregions-1

pltext

page


if auto='y' then
  LIBRARY_SEARCH('search')
endif      


" ********************************************** "
" Here we see if there is an argument after      "
" the macro name.  If the argument is (1)        "
" then this is for quant and library search      "
" ********************************************** "

if $#=1 then    " FFF - argument exists "

  if $1='library' then  " GGG - if argument is library do std sample printout "
    $e=0
    exists(userdir+'/DEA_Automation/data/LibrarySearch_'+solvent+'/'+$libraryname+'.fid','file'):$e

    if $e=1 then  " HHH - the library spectrum exists "
      $file='' $file=file
      vs=vs*0.5/0.6
      $vs_file=vs
      vp=0 cutoff=80 intmod='off'
      sp=-0.1p wp=10.1p
      $RP=rp $LP=lp
      text(sampid)
      atext(file)
      atext(date)
      deanumber
      pltext(0,60) pl pscale

      rt(userdir+'/DEA_Automation/data/LibrarySearch_'+solvent+'/'+$libraryname)
      cutoff='n' vp=90
      if $res>1 then lb=$res-1 wft else lb=0 wft endif
      dea_phasing('fast')
      intmod='off' sp=-0.2p wp=11p dc
      sp=0.5p wp=4p vsadj $vslow=vs
      sp=5p wp=1p vsadj $vs2=vs if $vs2<$vslow then $vslow=$vs2 endif
      sp=6.5p wp=4p vsadj $vs3=vs if $vs3<$vslow then $vslow=$vs3 endif
      vs=$vslow  
      sp=-0.1p wp=10.1p
      $width=wp $right=sp
      $hdo_spot=($width-(4.8*sfrq-$right))/$width*wcmax
      $methanol=($width-(3.4*sfrq-$right))/$width*wcmax
      $maleic_spot=($width-(6.3*sfrq-$right))/$width*wcmax
      $tms_spot=($width-(0-$right))/$width*wcmax

      if solvent='D2O' or solvent='d2o' or solvent='cd3od' or solvent='CD3OD' then
        write('plotter',$hdo_spot,wc2max*0.95,'solvent impurity')
      endif

      if solvent='D2O' or solvent='d2o' then
         write('plotter',$hdo_spot,wc2max*0.95-5,'    (HDO)')
         write('plotter',$tms_spot-5,wc2max/2+40,'TSP')
      endif

      if solvent='CD3OD' or solvent='cd3od' then
        write('plotter',$methanol,wc2max/2+40,'solvent impurity')
        write('plotter',$methanol,wc2max/2+36,'|')
        write('plotter',$tms_spot-5,wc2max/2+40,'TMS')
      endif

      if $is_name='maleic' then
        write('plotter',$maleic_spot,wc2max/2+40,'maleic acid')
        write('plotter',$maleic_spot-5,wc2max/2+36,' _|____')
      endif

      write('plotter',$tms_spot,wc2max/2+36,'|')
      
      pltext pl pscale page

      rt($file) lb=0 wft sp=-0.1p wp=10.1p dc rp=$RP lp=$LP vs=$vs_file
    else
      write('line3','Reference Standard Spectrum does not exist')     
    endif   " HHH "

  else
    write('line3','argument for this macro is not 1')
  endif   " GGG "

endif   " FFF "


